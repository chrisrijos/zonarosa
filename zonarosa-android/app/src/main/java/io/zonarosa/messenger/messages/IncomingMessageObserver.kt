package io.zonarosa.messenger.messages

import android.app.Application
import android.app.Service
import android.content.Context
import android.content.Intent
import android.os.IBinder
import androidx.annotation.VisibleForTesting
import androidx.core.app.NotificationCompat
import io.reactivex.rxjava3.disposables.Disposable
import io.reactivex.rxjava3.kotlin.subscribeBy
import io.reactivex.rxjava3.schedulers.Schedulers
import io.zonarosa.core.models.ServiceId
import io.zonarosa.core.util.concurrent.ZonaRosaExecutors
import io.zonarosa.core.util.logging.Log
import io.zonarosa.storageservice.storage.protos.groups.local.DecryptedGroup
import io.zonarosa.messenger.R
import io.zonarosa.messenger.crypto.ReentrantSessionLock
import io.zonarosa.messenger.database.ZonaRosaDatabase
import io.zonarosa.messenger.dependencies.AppDependencies
import io.zonarosa.messenger.groups.GroupsV2ProcessingLock
import io.zonarosa.messenger.groups.v2.processing.GroupsV2StateProcessor
import io.zonarosa.messenger.jobmanager.Job
import io.zonarosa.messenger.jobmanager.impl.BackoffUtil
import io.zonarosa.messenger.jobmanager.impl.NetworkConstraint
import io.zonarosa.messenger.jobs.ForegroundServiceUtil
import io.zonarosa.messenger.jobs.ForegroundServiceUtil.startWhenCapable
import io.zonarosa.messenger.jobs.PushProcessMessageErrorJob
import io.zonarosa.messenger.jobs.PushProcessMessageJob
import io.zonarosa.messenger.jobs.RequestGroupV2InfoJob
import io.zonarosa.messenger.jobs.UnableToStartException
import io.zonarosa.messenger.keyvalue.ZonaRosaStore
import io.zonarosa.messenger.keyvalue.isDecisionPending
import io.zonarosa.messenger.messages.MessageDecryptor.FollowUpOperation
import io.zonarosa.messenger.messages.protocol.BufferedProtocolStore
import io.zonarosa.messenger.notifications.NotificationChannels
import io.zonarosa.messenger.push.ZonaRosaServiceNetworkAccess.Companion.toApplicableSystemHttpProxy
import io.zonarosa.messenger.recipients.RecipientId
import io.zonarosa.messenger.util.AlarmSleepTimer
import io.zonarosa.messenger.util.AppForegroundObserver
import io.zonarosa.messenger.util.ZonaRosaLocalMetrics
import io.zonarosa.messenger.util.ZonaRosaTrace
import io.zonarosa.messenger.util.asChain
import io.zonarosa.service.api.util.SleepTimer
import io.zonarosa.service.api.util.UptimeSleepTimer
import io.zonarosa.service.api.websocket.ZonaRosaWebSocket
import io.zonarosa.service.api.websocket.WebSocketConnectionState
import io.zonarosa.service.api.websocket.WebSocketUnavailableException
import io.zonarosa.service.internal.configuration.HttpProxy
import io.zonarosa.service.internal.push.Envelope
import java.util.concurrent.CopyOnWriteArrayList
import java.util.concurrent.Semaphore
import java.util.concurrent.TimeUnit
import java.util.concurrent.TimeoutException
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock
import kotlin.math.round
import kotlin.time.Duration.Companion.minutes
import kotlin.time.Duration.Companion.seconds

/**
 * The application-level manager of our incoming message processing.
 *
 * This class is responsible for keeping the authenticated websocket open based on the app's state for incoming messages and
 * observing new inbound messages received over the websocket.
 */
class IncomingMessageObserver(
  private val context: Application,
  private val authWebSocket: ZonaRosaWebSocket.AuthenticatedWebSocket,
  private val unauthWebSocket: ZonaRosaWebSocket.UnauthenticatedWebSocket
) {

  companion object {
    private val TAG = Log.tag(IncomingMessageObserver::class.java)

    private const val WEB_SOCKET_KEEP_ALIVE_TOKEN = "MessageRetrieval"

    /** How long we wait for the websocket to time out before we try to connect again. */
    private val websocketReadTimeout: Long
      get() = if (censored) 30.seconds.inWholeMilliseconds else 1.minutes.inWholeMilliseconds

    /** How long the websocket is allowed to keep running after the user backgrounds the app. Higher numbers allow us to rely on FCM less. */
    private val maxBackgroundTime: Long
      get() = if (censored) 10.seconds.inWholeMilliseconds else 2.minutes.inWholeMilliseconds

    private val INSTANCE_COUNT = AtomicInteger(0)

    const val FOREGROUND_ID = 313399

    private val censored: Boolean
      get() = AppDependencies.zonarosaServiceNetworkAccess.isCensored()
  }

  private val decryptionDrainedListeners: MutableList<Runnable> = CopyOnWriteArrayList()

  private val lock: ReentrantLock = ReentrantLock()
  private val connectionNecessarySemaphore = Semaphore(0)
  private var previousSystemHttpProxy: HttpProxy? = null
  private val networkConnectionListener = NetworkConnectionListener(
    context = context,
    onNetworkLost = { isNetworkUnavailable ->
      lock.withLock {
        AppDependencies.libzonarosaNetwork.onNetworkChange()
        if (isNetworkUnavailable()) {
          Log.w(TAG, "Lost network connection. Resetting the drained state.")
          decryptionDrained = false
          authWebSocket.disconnect()
          // TODO [no-more-rest] Move the connection listener to a neutral location so this isn't passed in
          unauthWebSocket.disconnect()
        }
        connectionNecessarySemaphore.release()
      }
    },
    onProxySettingsChanged = { proxyInfo ->
      val systemHttpProxy = proxyInfo.toApplicableSystemHttpProxy()
      if (systemHttpProxy?.host != previousSystemHttpProxy?.host || systemHttpProxy?.port != previousSystemHttpProxy?.port) {
        val networkReset = AppDependencies.onSystemHttpProxyChange(systemHttpProxy)
        if (networkReset) {
          Log.i(TAG, "System proxy configuration changed, network reset.")
        }
      }
      previousSystemHttpProxy = systemHttpProxy
    }
  )

  private val messageContentProcessor = MessageContentProcessor.create(context)

  private var appVisible = false
  private var lastInteractionTime: Long = System.currentTimeMillis()
  private var webSocketStateDisposable = Disposable.disposed()

  @Volatile
  private var terminated = false

  @Volatile
  var decryptionDrained = false
    private set

  init {
    if (INSTANCE_COUNT.incrementAndGet() != 1) {
      throw AssertionError("Multiple observers!")
    }

    MessageRetrievalThread().start()

    if (!ZonaRosaStore.account.fcmEnabled || ZonaRosaStore.internal.isWebsocketModeForced) {
      try {
        ForegroundServiceUtil.start(context, Intent(context, ForegroundService::class.java))
      } catch (e: UnableToStartException) {
        Log.w(TAG, "Unable to start foreground service for websocket. Deferring to background to try with blocking")
        ZonaRosaExecutors.UNBOUNDED.execute {
          try {
            startWhenCapable(context, Intent(context, ForegroundService::class.java))
          } catch (e: UnableToStartException) {
            Log.w(TAG, "Unable to start foreground service for websocket!", e)
          }
        }
      }
    }

    AppForegroundObserver.addListener(object : AppForegroundObserver.Listener {
      override fun onForeground() {
        ZonaRosaExecutors.BOUNDED.execute { onAppForegrounded() }
      }

      override fun onBackground() {
        ZonaRosaExecutors.BOUNDED.execute { onAppBackgrounded() }
      }
    })

    networkConnectionListener.register()

    webSocketStateDisposable = authWebSocket
      .state
      .observeOn(Schedulers.computation())
      .subscribeBy {
        if (it == WebSocketConnectionState.CONNECTED) {
          lock.withLock {
            connectionNecessarySemaphore.release()
          }
        }
      }

    authWebSocket.addKeepAliveChangeListener {
      ZonaRosaExecutors.BOUNDED.execute {
        lock.withLock {
          connectionNecessarySemaphore.release()
        }
      }
    }
  }

  fun notifyRegistrationStateChanged() {
    connectionNecessarySemaphore.release()
  }

  fun notifyRestoreDecisionMade() {
    Log.i(TAG, "Restore decision made, can restart network and process messages")
    AppDependencies.resetNetwork()
  }

  fun addDecryptionDrainedListener(listener: Runnable) {
    decryptionDrainedListeners.add(listener)
    if (decryptionDrained) {
      listener.run()
    }
  }

  fun removeDecryptionDrainedListener(listener: Runnable) {
    decryptionDrainedListeners.remove(listener)
  }

  private fun onAppForegrounded() {
    lock.withLock {
      appVisible = true
      BackgroundService.start(context)
      connectionNecessarySemaphore.release()
    }
  }

  private fun onAppBackgrounded() {
    lock.withLock {
      appVisible = false
      lastInteractionTime = System.currentTimeMillis()
      connectionNecessarySemaphore.release()
    }
  }

  private fun isConnectionNecessary(): Boolean {
    val timeIdle: Long
    val appVisibleSnapshot: Boolean

    lock.withLock {
      appVisibleSnapshot = appVisible
      timeIdle = if (appVisibleSnapshot) 0 else System.currentTimeMillis() - lastInteractionTime
    }

    val registered = ZonaRosaStore.account.isRegistered
    val fcmEnabled = ZonaRosaStore.account.fcmEnabled
    val hasNetwork = NetworkConstraint.isMet(context)
    val hasProxy = ZonaRosaStore.proxy.isProxyEnabled
    val forceWebsocket = ZonaRosaStore.internal.isWebsocketModeForced
    val websocketAlreadyOpen = isConnectionAvailable()

    val lastInteractionString = if (appVisibleSnapshot) "N/A" else timeIdle.toString() + " ms (" + (if (timeIdle < maxBackgroundTime) "within limit" else "over limit") + ")"
    val conclusion = registered &&
      (appVisibleSnapshot || timeIdle < maxBackgroundTime || !fcmEnabled) &&
      hasNetwork

    val needsConnectionString = if (conclusion) "Needs Connection" else "Does Not Need Connection"

    Log.d(TAG, "[$needsConnectionString] Network: $hasNetwork, Foreground: $appVisibleSnapshot, Time Since Last Interaction: $lastInteractionString, FCM: $fcmEnabled, WS Open or Keep-alives: $websocketAlreadyOpen, Registered: $registered, Proxy: $hasProxy, Force websocket: $forceWebsocket")
    return conclusion
  }

  private fun isConnectionAvailable(): Boolean {
    return ZonaRosaStore.account.isRegistered && (authWebSocket.stateSnapshot == WebSocketConnectionState.CONNECTED || (authWebSocket.shouldSendKeepAlives() && NetworkConstraint.isMet(context)))
  }

  private fun waitForConnectionNecessary() {
    try {
      connectionNecessarySemaphore.drainPermits()
      while (!isConnectionNecessary() && !isConnectionAvailable()) {
        val numberDrained = connectionNecessarySemaphore.drainPermits()
        if (numberDrained == 0) {
          connectionNecessarySemaphore.acquire()
        }
      }
    } catch (e: InterruptedException) {
      throw AssertionError(e)
    }
  }

  fun terminate() {
    Log.w(TAG, "Termination! ${this.hashCode()}", Throwable())
    INSTANCE_COUNT.decrementAndGet()
    networkConnectionListener.unregister()
    webSocketStateDisposable.dispose()
    terminated = true
    authWebSocket.disconnect()
  }

  @VisibleForTesting
  fun processEnvelope(bufferedProtocolStore: BufferedProtocolStore, envelope: Envelope, serverDeliveredTimestamp: Long, batchCache: BatchCache): List<FollowUpOperation>? {
    return when (envelope.type) {
      Envelope.Type.SERVER_DELIVERY_RECEIPT -> {
        ZonaRosaTrace.beginSection("IncomingMessageObserver#processReceipt")
        processReceipt(envelope)
        ZonaRosaTrace.endSection()
        null
      }

      Envelope.Type.PREKEY_BUNDLE,
      Envelope.Type.CIPHERTEXT,
      Envelope.Type.UNIDENTIFIED_SENDER,
      Envelope.Type.PLAINTEXT_CONTENT -> {
        ZonaRosaTrace.beginSection("IncomingMessageObserver#processMessage")
        val followUps = processMessage(bufferedProtocolStore, envelope, serverDeliveredTimestamp, batchCache)
        ZonaRosaTrace.endSection()
        followUps
      }

      else -> {
        Log.w(TAG, "Received envelope of unknown type: " + envelope.type)
        null
      }
    }
  }

  private fun processMessage(bufferedProtocolStore: BufferedProtocolStore, envelope: Envelope, serverDeliveredTimestamp: Long, batchCache: BatchCache): List<FollowUpOperation> {
    val localReceiveMetric = ZonaRosaLocalMetrics.MessageReceive.start()
    ZonaRosaTrace.beginSection("IncomingMessageObserver#decryptMessage")
    val result = MessageDecryptor.decrypt(context, bufferedProtocolStore, envelope, serverDeliveredTimestamp)
    ZonaRosaTrace.endSection()
    localReceiveMetric.onEnvelopeDecrypted()

    ZonaRosaLocalMetrics.MessageLatency.onMessageReceived(envelope.serverTimestamp!!, serverDeliveredTimestamp, envelope.urgent!!)
    when (result) {
      is MessageDecryptor.Result.Success -> {
        val job = PushProcessMessageJob.processOrDefer(messageContentProcessor, result, localReceiveMetric, batchCache)
        if (job != null) {
          return result.followUpOperations + FollowUpOperation { job.asChain() }
        }
      }
      is MessageDecryptor.Result.Error -> {
        return result.followUpOperations + FollowUpOperation {
          val jobs = mutableListOf<Job>()

          if (result.errorMetadata.groupMasterKey != null) {
            val groupId = result.errorMetadata.groupId!!
            if (!ZonaRosaDatabase.groups.getGroup(groupId).isPresent) {
              Log.w(TAG, "Decryption error in group, but group not found. Creating placeholder for groupId: $groupId")
              ZonaRosaDatabase.groups.create(
                groupMasterKey = result.errorMetadata.groupMasterKey!!,
                groupState = DecryptedGroup(revision = GroupsV2StateProcessor.RESTORE_PLACEHOLDER_REVISION),
                groupSendEndorsements = null
              )
              jobs += RequestGroupV2InfoJob(groupId)
            }
          }

          jobs += PushProcessMessageErrorJob(
            result.toMessageState(),
            result.errorMetadata.toExceptionMetadata(),
            result.envelope.timestamp!!
          )

          AppDependencies.jobManager.startChain(jobs)
        }
      }
      is MessageDecryptor.Result.Ignore -> {
        // No action needed
      }
      else -> {
        throw AssertionError("Unexpected result! ${result.javaClass.simpleName}")
      }
    }

    return result.followUpOperations
  }

  private fun processReceipt(envelope: Envelope) {
    val serviceId = ServiceId.parseOrNull(envelope.sourceServiceId, envelope.sourceServiceIdBinary)
    if (serviceId == null) {
      Log.w(TAG, "Invalid envelope sourceServiceId!")
      return
    }

    val senderId = RecipientId.from(serviceId)

    Log.i(TAG, "Received server receipt. Sender: $senderId, Device: ${envelope.sourceDevice}, Timestamp: ${envelope.timestamp}")
    ZonaRosaDatabase.messages.incrementDeliveryReceiptCount(envelope.timestamp!!, senderId, System.currentTimeMillis())
    ZonaRosaDatabase.messageLog.deleteEntryForRecipient(envelope.timestamp!!, senderId, envelope.sourceDevice!!)
  }

  private fun MessageDecryptor.Result.toMessageState(): MessageState {
    return when (this) {
      is MessageDecryptor.Result.DecryptionError -> MessageState.DECRYPTION_ERROR
      is MessageDecryptor.Result.Ignore -> MessageState.NOOP
      is MessageDecryptor.Result.InvalidVersion -> MessageState.INVALID_VERSION
      is MessageDecryptor.Result.LegacyMessage -> MessageState.LEGACY_MESSAGE
      is MessageDecryptor.Result.Success -> MessageState.DECRYPTED_OK
      is MessageDecryptor.Result.UnsupportedDataMessage -> MessageState.UNSUPPORTED_DATA_MESSAGE
    }
  }

  private fun MessageDecryptor.ErrorMetadata.toExceptionMetadata(): ExceptionMetadata {
    return ExceptionMetadata(
      this.sender,
      this.senderDevice,
      this.groupId
    )
  }

  private inner class MessageRetrievalThread : Thread("MessageRetrievalService"), Thread.UncaughtExceptionHandler {

    private var sleepTimer: SleepTimer
    private val canProcessMessages: Boolean
    private val batchCache = ReusedBatchCache()

    init {
      Log.i(TAG, "Initializing! (${this.hashCode()})")
      uncaughtExceptionHandler = this

      sleepTimer = if (!ZonaRosaStore.account.fcmEnabled || ZonaRosaStore.internal.isWebsocketModeForced) AlarmSleepTimer(context) else UptimeSleepTimer()

      canProcessMessages = !ZonaRosaStore.registration.restoreDecisionState.isDecisionPending
    }

    override fun run() {
      var attempts = 0

      while (!terminated) {
        Log.i(TAG, "Waiting for websocket state change....")
        if (attempts > 1) {
          val backoff = BackoffUtil.exponentialBackoff(attempts, TimeUnit.SECONDS.toMillis(30))
          Log.w(TAG, "Too many failed connection attempts,  attempts: $attempts backing off: $backoff")
          sleepTimer.sleep(backoff)
        }

        waitForConnectionNecessary()
        Log.i(TAG, "Making websocket connection....")

        val webSocketDisposable = authWebSocket.state.subscribe { state: WebSocketConnectionState ->
          Log.d(TAG, "WebSocket State: $state")

          // Any change to a non-connected state means that we are not drained
          if (state != WebSocketConnectionState.CONNECTED) {
            decryptionDrained = false
          }

          if (state == WebSocketConnectionState.CONNECTED) {
            ZonaRosaStore.misc.lastWebSocketConnectTime = System.currentTimeMillis()
          }
        }

        try {
          authWebSocket.connect()
          var isConnectionNecessary = false
          while (!terminated && (isConnectionNecessary().also { isConnectionNecessary = it } || isConnectionAvailable())) {
            if (isConnectionNecessary) {
              authWebSocket.registerKeepAliveToken(WEB_SOCKET_KEEP_ALIVE_TOKEN)
            } else {
              authWebSocket.removeKeepAliveToken(WEB_SOCKET_KEEP_ALIVE_TOKEN)
            }

            try {
              if (canProcessMessages) {
                Log.d(TAG, "Reading message...")

                val hasMore = authWebSocket.readMessageBatch(websocketReadTimeout, 30) { batch ->
                  Log.i(TAG, "Retrieved ${batch.size} envelopes!")
                  val bufferedStore = BufferedProtocolStore.create()

                  val startTime = System.currentTimeMillis()
                  GroupsV2ProcessingLock.acquireGroupProcessingLock().use {
                    ReentrantSessionLock.INSTANCE.acquire().use {
                      batch.forEach { response ->
                        ZonaRosaTrace.beginSection("IncomingMessageObserver#perMessageTransaction")
                        val followUpOperations = ZonaRosaDatabase.runInTransaction { db ->
                          val followUps: List<FollowUpOperation>? = processEnvelope(bufferedStore, response.envelope, response.serverDeliveredTimestamp, batchCache)
                          bufferedStore.flushToDisk()
                          followUps
                        }
                        ZonaRosaTrace.endSection()

                        if (followUpOperations?.isNotEmpty() == true) {
                          Log.d(TAG, "Running ${followUpOperations.size} follow-up operations...")
                          val jobs = followUpOperations.mapNotNull { it.run() }
                          AppDependencies.jobManager.addAllChains(jobs)
                        }

                        authWebSocket.sendAck(response)
                      }

                      batchCache.flushAndClear()
                    }
                  }
                  val duration = System.currentTimeMillis() - startTime
                  val timePerMessage: Float = duration / batch.size.toFloat()
                  Log.d(TAG, "Decrypted ${batch.size} envelopes in $duration ms (~${round(timePerMessage * 100) / 100} ms per message)")
                }
                attempts = 0
                ZonaRosaLocalMetrics.PushWebsocketFetch.onProcessedBatch()

                if (!hasMore && !decryptionDrained) {
                  ZonaRosaTrace.endSection()
                  Log.i(TAG, "Decryptions newly-drained.")
                  decryptionDrained = true

                  for (listener in decryptionDrainedListeners.toList()) {
                    listener.run()
                  }
                } else if (!hasMore) {
                  Log.w(TAG, "Got tombstone, but we thought the network was already drained!")
                }
              } else {
                Log.d(TAG, "Reading and dropping message...")
                authWebSocket.readMessageBatch(websocketReadTimeout, 30) { batch ->
                  Log.w(TAG, "Retrieved ${batch.size} envelopes but dropping until we can finish backup restore.")
                }
                attempts = 0
              }
            } catch (e: WebSocketUnavailableException) {
              Log.i(TAG, "Pipe unexpectedly unavailable, connecting")
              authWebSocket.connect()
            } catch (e: TimeoutException) {
              Log.w(TAG, "Application level read timeout...")
              attempts = 0
            }
          }

          if (!appVisible) {
            BackgroundService.stop(context)
          }
        } catch (e: Throwable) {
          attempts++
          Log.w(TAG, e)
        } finally {
          Log.w(TAG, "Disconnecting auth websocket")
          authWebSocket.disconnect()
          webSocketDisposable.dispose()
          decryptionDrained = false
        }
        Log.i(TAG, "Looping...")
      }
      Log.w(TAG, "Terminated! (${this.hashCode()})")
    }

    override fun uncaughtException(t: Thread, e: Throwable) {
      Log.w(TAG, "Uncaught exception in message thread!", e)
    }
  }

  class ForegroundService : Service() {
    override fun onBind(intent: Intent?): IBinder? {
      return null
    }

    override fun onCreate() {
      postForegroundNotification()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
      super.onStartCommand(intent, flags, startId)

      postForegroundNotification()

      return START_STICKY
    }

    private fun postForegroundNotification() {
      val notification = NotificationCompat.Builder(applicationContext, NotificationChannels.getInstance().BACKGROUND)
        .setContentTitle(applicationContext.getString(R.string.MessageRetrievalService_zonarosa))
        .setContentText(applicationContext.getString(R.string.MessageRetrievalService_background_connection_enabled))
        .setPriority(NotificationCompat.PRIORITY_MIN)
        .setWhen(0)
        .setSmallIcon(R.drawable.ic_zonarosa_background_connection)
        .build()

      startForeground(FOREGROUND_ID, notification)
    }
  }

  /**
   * A service that exists just to encourage the system to keep our process alive a little longer.
   */
  class BackgroundService : Service() {
    override fun onBind(intent: Intent?): IBinder? = null

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
      Log.d(TAG, "Background service started.")
      return START_STICKY
    }

    override fun onDestroy() {
      Log.d(TAG, "Background service destroyed.")
    }

    companion object {
      fun start(context: Context) {
        try {
          context.startService(Intent(context, BackgroundService::class.java))
        } catch (e: Exception) {
          Log.w(TAG, "Failed to start background service.", e)
        }
      }

      fun stop(context: Context) {
        context.stopService(Intent(context, BackgroundService::class.java))
      }
    }
  }
}
