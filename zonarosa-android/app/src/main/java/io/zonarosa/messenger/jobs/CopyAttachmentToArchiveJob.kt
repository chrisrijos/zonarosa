package io.zonarosa.messenger.jobs

import kotlinx.coroutines.runBlocking
import io.zonarosa.core.models.backup.MediaName
import io.zonarosa.core.util.Base64.decodeBase64
import io.zonarosa.core.util.ByteSize
import io.zonarosa.core.util.bytes
import io.zonarosa.core.util.logging.Log
import io.zonarosa.core.util.logging.logW
import io.zonarosa.libzonarosa.zkgroup.VerificationFailedException
import io.zonarosa.messenger.attachments.AttachmentId
import io.zonarosa.messenger.attachments.Cdn
import io.zonarosa.messenger.attachments.DatabaseAttachment
import io.zonarosa.messenger.backup.ArchiveUploadProgress
import io.zonarosa.messenger.backup.v2.ArchiveDatabaseExecutor
import io.zonarosa.messenger.backup.v2.BackupRepository
import io.zonarosa.messenger.backup.v2.hadIntegrityCheckPerformed
import io.zonarosa.messenger.database.AttachmentTable
import io.zonarosa.messenger.database.ZonaRosaDatabase
import io.zonarosa.messenger.dependencies.AppDependencies
import io.zonarosa.messenger.jobmanager.Job
import io.zonarosa.messenger.jobmanager.impl.NetworkConstraint
import io.zonarosa.messenger.jobmanager.impl.NoRemoteArchiveGarbageCollectionPendingConstraint
import io.zonarosa.messenger.jobs.protos.CopyAttachmentToArchiveJobData
import io.zonarosa.messenger.keyvalue.ZonaRosaStore
import io.zonarosa.messenger.util.MediaUtil
import io.zonarosa.messenger.util.RemoteConfig
import io.zonarosa.service.api.NetworkResult
import java.util.concurrent.TimeUnit

/**
 * Copies and re-encrypts attachments from the attachment cdn to the archive cdn.
 * If it's discovered that the attachment no longer exists on the attachment cdn, this job will schedule a re-upload via [UploadAttachmentToArchiveJob].
 *
 * This job runs at high priority within its queue, which it shares with [UploadAttachmentToArchiveJob]. Therefore, copies are given priority over new uploads,
 * which allows the two-part archive upload process to finish quickly.
 */
class CopyAttachmentToArchiveJob private constructor(private val attachmentId: AttachmentId, parameters: Parameters) : Job(parameters) {

  companion object {
    private val TAG = Log.tag(CopyAttachmentToArchiveJob::class.java)

    const val KEY = "CopyAttachmentToArchiveJob"

    /** CDNs that we can copy data from */
    val ALLOWED_SOURCE_CDNS = setOf(Cdn.CDN_2, Cdn.CDN_3)
  }

  constructor(attachmentId: AttachmentId) : this(
    attachmentId = attachmentId,
    parameters = Parameters.Builder()
      .addConstraint(NetworkConstraint.KEY)
      .addConstraint(NoRemoteArchiveGarbageCollectionPendingConstraint.KEY)
      .setLifespan(TimeUnit.DAYS.toMillis(1))
      .setMaxAttempts(Parameters.UNLIMITED)
      .setQueue(UploadAttachmentToArchiveJob.QUEUES.random())
      .setQueuePriority(Parameters.PRIORITY_HIGH)
      .setGlobalPriority(Parameters.PRIORITY_LOW)
      .build()
  )

  override fun serialize(): ByteArray = CopyAttachmentToArchiveJobData(
    attachmentId = attachmentId.id
  ).encode()

  override fun getFactoryKey(): String = KEY

  override fun onAdded() {
    val transferStatus = ZonaRosaDatabase.attachments.getArchiveTransferState(attachmentId) ?: return

    if (transferStatus == AttachmentTable.ArchiveTransferState.NONE || transferStatus == AttachmentTable.ArchiveTransferState.UPLOAD_IN_PROGRESS) {
      Log.d(TAG, "[$attachmentId] Updating archive transfer state to ${AttachmentTable.ArchiveTransferState.COPY_PENDING}")
      setArchiveTransferStateWithDelayedNotification(attachmentId, AttachmentTable.ArchiveTransferState.COPY_PENDING)
    }
  }

  override fun run(): Result {
    if (ZonaRosaStore.account.isLinkedDevice) {
      Log.w(TAG, "[$attachmentId] Linked devices don't backup media. Skipping.")
      setArchiveTransferStateWithDelayedNotification(attachmentId, AttachmentTable.ArchiveTransferState.NONE)
      return Result.success()
    }

    if (!ZonaRosaStore.backup.backsUpMedia) {
      Log.w(TAG, "[$attachmentId] This user does not back up media. Skipping.")
      return Result.success()
    }

    val attachment: DatabaseAttachment? = ZonaRosaDatabase.attachments.getAttachment(attachmentId)

    if (attachment == null) {
      Log.w(TAG, "[$attachmentId] Attachment no longer exists! Skipping.")
      return Result.failure()
    }

    val mediaIdLog: String = if (RemoteConfig.internalUser && attachment.remoteKey != null && attachment.dataHash != null) {
      val mediaId = MediaName.fromPlaintextHashAndRemoteKey(attachment.dataHash.decodeBase64()!!, attachment.remoteKey.decodeBase64()!!).toMediaId(ZonaRosaStore.backup.mediaRootBackupKey)
      "[$mediaId]"
    } else {
      ""
    }

    if (attachment.archiveTransferState == AttachmentTable.ArchiveTransferState.FINISHED) {
      Log.i(TAG, "[$attachmentId]$mediaIdLog Already finished. Skipping.")
      return Result.success()
    }

    if (attachment.archiveTransferState == AttachmentTable.ArchiveTransferState.PERMANENT_FAILURE) {
      Log.i(TAG, "[$attachmentId]$mediaIdLog Already marked as a permanent failure. Skipping.")
      return Result.failure()
    }

    if (ZonaRosaDatabase.messages.isStory(attachment.mmsId)) {
      Log.i(TAG, "[$attachmentId]$mediaIdLog Attachment is a story. Resetting transfer state to none and skipping.")
      setArchiveTransferStateWithDelayedNotification(attachmentId, AttachmentTable.ArchiveTransferState.NONE)
      return Result.success()
    }

    if (ZonaRosaDatabase.messages.isViewOnce(attachment.mmsId)) {
      Log.i(TAG, "[$attachmentId]$mediaIdLog Attachment is view-once. Resetting transfer state to none and skipping.")
      setArchiveTransferStateWithDelayedNotification(attachmentId, AttachmentTable.ArchiveTransferState.NONE)
      return Result.success()
    }

    if (ZonaRosaDatabase.messages.willMessageExpireBeforeCutoff(attachment.mmsId)) {
      Log.i(TAG, "[$attachmentId]$mediaIdLog Message will expire in less than 24 hours. Resetting transfer state to none and skipping.")
      setArchiveTransferStateWithDelayedNotification(attachmentId, AttachmentTable.ArchiveTransferState.NONE)
      return Result.success()
    }

    if (attachment.contentType == MediaUtil.LONG_TEXT) {
      Log.i(TAG, "[$attachmentId]$mediaIdLog Attachment is long text. Resetting transfer state to none and skipping.")
      setArchiveTransferStateWithDelayedNotification(attachmentId, AttachmentTable.ArchiveTransferState.NONE)
      return Result.success()
    }

    if (!attachment.hadIntegrityCheckPerformed()) {
      Log.w(TAG, "[$attachmentId]$mediaIdLog Attachment has not had its integrity check performed yet (transferState: ${attachment.transferState}). Resetting transfer state to none and skipping.")
      setArchiveTransferStateWithDelayedNotification(attachmentId, AttachmentTable.ArchiveTransferState.NONE)
      return Result.success()
    }

    if (attachment.cdn !in ALLOWED_SOURCE_CDNS) {
      Log.i(TAG, "[$attachmentId]$mediaIdLog Attachment CDN (${attachment.cdn}) is not in allowed source CDNs. Enqueueing an upload job instead.")
      setArchiveTransferStateWithDelayedNotification(attachmentId, AttachmentTable.ArchiveTransferState.NONE)
      AppDependencies.jobManager.add(UploadAttachmentToArchiveJob(attachmentId, canReuseUpload = false))
      return Result.success()
    }

    if (attachment.remoteLocation == null) {
      Log.i(TAG, "[$attachmentId]$mediaIdLog Attachment has no remote location. Enqueueing an upload job instead.")
      setArchiveTransferStateWithDelayedNotification(attachmentId, AttachmentTable.ArchiveTransferState.NONE)
      AppDependencies.jobManager.add(UploadAttachmentToArchiveJob(attachmentId, canReuseUpload = false))
      return Result.success()
    }

    if (attachment.archiveTransferState == AttachmentTable.ArchiveTransferState.NONE) {
      Log.i(TAG, "[$attachmentId]$mediaIdLog Not marked as pending copy. Enqueueing an upload job instead.")
      AppDependencies.jobManager.add(UploadAttachmentToArchiveJob(attachmentId))
      return Result.success()
    }

    if (isCanceled) {
      Log.w(TAG, "[$attachmentId]$mediaIdLog Canceled. Refusing to proceed.")
      return Result.failure()
    }

    val result = when (val archiveResult = BackupRepository.copyAttachmentToArchive(attachment)) {
      is NetworkResult.Success -> {
        Log.i(TAG, "[$attachmentId]$mediaIdLog Successfully copied the archive tier.")
        Result.success()
      }

      is NetworkResult.NetworkError -> {
        Log.w(TAG, "[$attachmentId]$mediaIdLog Encountered a retryable network error.", archiveResult.exception)
        Result.retry(defaultBackoff())
      }

      is NetworkResult.StatusCodeError -> {
        when (archiveResult.code) {
          400 -> {
            Log.w(TAG, "[$attachmentId]$mediaIdLog Something is invalid about our request. Possibly the length. Scheduling a re-upload. Body: ${archiveResult.exception.stringBody}")
            setArchiveTransferStateWithDelayedNotification(attachmentId, AttachmentTable.ArchiveTransferState.NONE)
            AppDependencies.jobManager.add(UploadAttachmentToArchiveJob(attachmentId, canReuseUpload = false))
            Result.success()
          }
          403 -> {
            Log.w(TAG, "[$attachmentId]$mediaIdLog Insufficient permissions to upload. Handled in parent handler.")
            Result.success()
          }
          410 -> {
            Log.w(TAG, "[$attachmentId]$mediaIdLog The attachment no longer exists on the transit tier. Scheduling a re-upload.")
            setArchiveTransferStateWithDelayedNotification(attachmentId, AttachmentTable.ArchiveTransferState.NONE)
            AppDependencies.jobManager.add(UploadAttachmentToArchiveJob(attachmentId, canReuseUpload = false))
            Result.success()
          }
          413 -> {
            Log.w(TAG, "[$attachmentId]$mediaIdLog Insufficient storage space! Can't upload!")
            val remoteStorageQuota = getServerQuota() ?: return Result.retry(defaultBackoff()).logW(TAG, "[$attachmentId] Failed to fetch server quota! Retrying.")

            if (ZonaRosaDatabase.attachments.getPaidEstimatedArchiveMediaSize() > remoteStorageQuota.inWholeBytes) {
              BackupRepository.markOutOfRemoteStorageSpaceError()
              return Result.failure()
            }

            Log.i(TAG, "[$attachmentId]$mediaIdLog Remote storage is full, but our local state indicates that once we reconcile our storage, we should have enough. Enqueuing the reconciliation job and retrying.")
            ZonaRosaStore.backup.remoteStorageGarbageCollectionPending = true
            ArchiveAttachmentReconciliationJob.enqueueIfRetryAllowed(forced = true)

            Result.retry(defaultBackoff())
          }
          429 -> {
            Log.w(TAG, "[$attachmentId]$mediaIdLog Rate limit exceeded. Retrying.")
            Result.retry(archiveResult.retryAfter()?.inWholeMilliseconds ?: defaultBackoff())
          }
          else -> {
            Log.w(TAG, "[$attachmentId]$mediaIdLog Got back a non-2xx status code: ${archiveResult.code}. Retrying.")
            Result.retry(defaultBackoff())
          }
        }
      }

      is NetworkResult.ApplicationError -> {
        if (archiveResult.throwable is VerificationFailedException) {
          Log.w(TAG, "[$attachmentId]$mediaIdLog Encountered a verification failure when trying to upload! Retrying.")
          Result.retry(defaultBackoff())
        } else {
          Log.w(TAG, "[$attachmentId]$mediaIdLog Encountered a fatal error when trying to upload!")
          Result.fatalFailure(RuntimeException(archiveResult.throwable))
        }
      }
    }

    if (result.isSuccess) {
      Log.d(TAG, "[$attachmentId]$mediaIdLog Updating archive transfer state to ${AttachmentTable.ArchiveTransferState.FINISHED}")
      ArchiveDatabaseExecutor.runBlocking {
        ZonaRosaDatabase.attachments.setArchiveTransferState(attachmentId, attachment.remoteKey!!, attachment.dataHash!!, AttachmentTable.ArchiveTransferState.FINISHED, notify = false)
        ArchiveDatabaseExecutor.throttledNotifyAttachmentObservers()
      }

      if (!isCanceled) {
        if (!attachment.quote) {
          ArchiveThumbnailUploadJob.enqueueIfNecessary(attachmentId)
        } else {
          Log.d(TAG, "[$attachmentId]$mediaIdLog Refusing to enqueue thumb for quote attachment.")
        }
      } else {
        Log.d(TAG, "[$attachmentId]$mediaIdLog Refusing to enqueue thumb for canceled upload.")
      }

      ArchiveUploadProgress.onAttachmentFinished(attachmentId)
      ZonaRosaStore.backup.archiveAttachmentReconciliationAttempts = 0
    }

    return result
  }

  private fun getServerQuota(): ByteSize? {
    return runBlocking {
      BackupRepository.getPaidType().successOrThrow().storageAllowanceBytes?.bytes
    }
  }

  override fun onFailure() {
    if (this.isCanceled) {
      Log.w(TAG, "[$attachmentId] Job was canceled, updating archive transfer state to ${AttachmentTable.ArchiveTransferState.COPY_PENDING}.")
      ArchiveDatabaseExecutor.runBlocking {
        ZonaRosaDatabase.attachments.setArchiveTransferState(attachmentId, AttachmentTable.ArchiveTransferState.COPY_PENDING)
      }
    } else {
      Log.w(TAG, "[$attachmentId] Job failed, updating archive transfer state to ${AttachmentTable.ArchiveTransferState.TEMPORARY_FAILURE}.")
      ArchiveDatabaseExecutor.runBlocking {
        ZonaRosaDatabase.attachments.setArchiveTransferStateFailure(attachmentId, AttachmentTable.ArchiveTransferState.TEMPORARY_FAILURE)
      }
    }

    ArchiveUploadProgress.onAttachmentFinished(attachmentId)
  }

  private fun setArchiveTransferStateWithDelayedNotification(attachmentId: AttachmentId, transferState: AttachmentTable.ArchiveTransferState) {
    ArchiveDatabaseExecutor.runBlocking {
      ZonaRosaDatabase.attachments.setArchiveTransferState(attachmentId, transferState, notify = false)
      ArchiveDatabaseExecutor.throttledNotifyAttachmentObservers()
    }
  }

  class Factory : Job.Factory<CopyAttachmentToArchiveJob> {
    override fun create(parameters: Parameters, serializedData: ByteArray?): CopyAttachmentToArchiveJob {
      val jobData = CopyAttachmentToArchiveJobData.ADAPTER.decode(serializedData!!)
      return CopyAttachmentToArchiveJob(
        attachmentId = AttachmentId(jobData.attachmentId),
        parameters = parameters
      )
    }
  }
}
